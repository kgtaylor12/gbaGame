#include "main.h"

#include <stdio.h>
#include <stdlib.h>

#include "gba.h"
#include "images/beach.h"
#include "images/gamescreen.h"
#include "images/gameover.h"
#include "images/youwon.h"
#include "images/youlost.h"
#include "images/star.h"


enum gamestate {
  INITSPLASH,
  DRAWSPLASH,
  WAITSPLASH,
  INITBOUNCE,
  BOUNCE,
  PAUSE,
  QUIT,
  WIN,
  LOSE
};
/* TODO: */
// Include any header files for title screen or exit
// screen images generated by nin10kit. Example for the provided garbage
// image:
// #include "images/garbage.h"

/* TODO: */
// Add any additional states you need for your app. You are not required to use
// these specific provided states.
struct state {
    enum gamestate gamestate;
    struct ball ball;
    struct rectangle rectangle;
    int size;
    int score;
    int lives;
    int level;
};



int main(void) {
  /* TODO: */
  // Manipulate REG_DISPCNT here to set Mode 3. //
  REG_DISPCNT = MODE3 | BG2_ENABLE;


  // Gamestate transitions:
	//	INITSPLASH -> DRAWSPLASH
	//	DRAWSPLASH -> WAITSPLASH (when ball dropped)
	//	WAITSPLASH -> INITBOUNCE (when START pressed)
	//	INITBOUNCE -> BOUNCE
	//	BOUNCE -> QUIT (when SELECT key pressed)
	//	BOUNCE -> PAUSE (when A key pressed)
  //  BOUNCE -> WIN (when score reaches threshold)
  //  BOUNCE -> LOSE (when lives <= 0)
	//	PAUSE -> BOUNCE (when A key pressed)
	//	QUIT -> INITSPLASH (when SELECT key pressed)


	


  // Save current and previous state of button input.
  u32 previousButtons = BUTTONS;
  u32 currentButtons = BUTTONS;

  // Load initial application state
  //enum gba_state state = START;
  //struct ball *bp;
  //struct rectangle *rp;

  //current and previous states
  struct state cs, ps;
  cs.gamestate = INITSPLASH;
  struct ball *bp, *obp;
  struct rectangle *rp, *orp;
  

  int buttonWasDown[NBUTTONS] = {0};
	int buttonJustReleased[NBUTTONS] = {0};
  ps = cs;

  while (1) {
   

    int deltas[] = { -3, -2, -1, 1, 2, 3 };
	  int ndeltas = sizeof(deltas) / sizeof(deltas[0]);
    int colors[] = {BLACK, RED, BLUE, GREEN, GRAY, CYAN};
    //int ncolors = 8;
    //currentButtons = BUTTONS; // Load the current state of the buttons
    for (int i=0; i<NBUTTONS; i++) {
			buttonJustReleased[i] = KEY_DOWN(i, BUTTONS) == 0 && buttonWasDown[i];
			buttonWasDown[i] = KEY_DOWN(i, BUTTONS) != 0;
		}

    
    // Manipulate the state machine below as needed //
    // NOTE: Call waitForVBlank() before you draw

    switch (cs.gamestate) {
	// Gamestate transitions:
	//	INITSPLASH -> DRAWSPLASH
	//	DRAWSPLASH -> WAITSPLASH (when ball dropped)
	//	WAITSPLASH -> INITBOUNCE (when START pressed)
	//	INITBOUNCE -> BOUNCE
	//	BOUNCE -> QUIT (when SELECT key pressed)
	//	BOUNCE -> PAUSE (when A key pressed)
	//	PAUSE -> BOUNCE (when A key pressed)
	//	QUIT -> INITSPLASH (when SELECT key pressed)
  //  BOUNCE -> WIN (when score reaches threshold)
      case INITSPLASH:
        // Set up the initial state
        cs.lives = 3;
			  cs.size = STAR_WIDTH;
			  cs.score = 0;
			  cs.ball.row = 0;
			  cs.ball.col = 80 + 2 * cs.size;
			  cs.ball.rd = 1;
			  cs.ball.cd = 1;
			  cs.ball.color = MAGENTA;
        cs.rectangle.height = 4;
			  cs.rectangle.width = 24;
        cs.rectangle.row = HEIGHT - cs.rectangle.height - 15;
			  cs.rectangle.col = WIDTH / 2 + cs.rectangle.width/2;
			  cs.rectangle.color = GRAY;
			  break;

      case DRAWSPLASH:
        // state = ?
        break;
      case WAITSPLASH:
        // state = ?
        break;

      case INITBOUNCE:
       //undraw inital rectangle
        //drawRectDMA(150, 5, 200, 10, bgcolor);
        drawImageDMA(150,5,200,10, gamescreen);
		  	cs.size = STAR_WIDTH;
				cs.ball.row = rand() % HEIGHT;
				cs.ball.col = rand() % WIDTH;
				cs.ball.rd = deltas[rand() % ndeltas];
				cs.ball.cd = deltas[rand() % ndeltas];

        cs.rectangle.height = 4;
			  cs.rectangle.width = 24;
        cs.rectangle.row = HEIGHT - cs.rectangle.height - 15;
			  cs.rectangle.col = WIDTH / 2 + cs.rectangle.width/2;
			  cs.rectangle.color = colors[rand()];

        // state = ?
        break;
      case BOUNCE:

        if (buttonJustReleased[BUTTON_UP]) {
          rp->row = rp->row - 8;
				  if(rp->row <= 0) {
					  rp->row = 0;
				  }
          if(rp->col <= 0) {
					  rp->col = 1;
				  } else if (rp->col >= WIDTH - rp->width) {
            rp->col = WIDTH-rp->width - 1;
          }
			  }

        if (buttonJustReleased[BUTTON_DOWN]) {
          rp->row = rp->row + 8;
				  if (rp->row >= HEIGHT - rp->height) {
            rp->row = HEIGHT-rp->height;
          }
          if(rp->col <= 0) {
					  rp->col = 1;
				  } else if (rp->col >= WIDTH - rp->width) {
            rp->col = WIDTH-rp->width - 1;
          }
			  }

        if (buttonJustReleased[BUTTON_LEFT]) {
          rp->col = rp->col - 24;
				  if (rp->row >= HEIGHT - rp->height) {
            rp->row = HEIGHT-rp->height;
          } else if (rp->row < 1) {
            rp->row = 0;
          }

          if(rp->col <= 1) {
					  rp->col = 1;
				  }
			  }

        if (buttonJustReleased[BUTTON_RIGHT]) {
          rp->col = rp->col + 24;
				  if (rp->row >= HEIGHT - rp->height) {
            rp->row = HEIGHT-rp->height;
          } else if (rp->row < 1) {
            rp->row = 0;
          }

          if (rp->col >= WIDTH - rp->width) {
            rp->col = WIDTH-rp->width - 1;
          }
			  }



				bp = &cs.ball;
				bp->row = bp->row + bp->rd;
				bp->col += bp->cd;
				if(bp->row < 0) {
					bp->row = 0;
					bp->rd = -bp->rd;
					cs.score++;
				}
				if(bp->row > HEIGHT-cs.size - 10) {
					bp->row = HEIGHT - cs.size - 10;
					bp->rd = -bp->rd;
          cs.lives--;
          cs.score--;
				}
				if(bp->col < 0) {
					bp->col = 0;
					bp->cd = -bp->cd;

				}
				if(bp->col > WIDTH-cs.size) {
					bp->col = WIDTH - cs.size;
					bp->cd = -bp->cd;
				}
        //collision
        orp = &ps.rectangle;
        if ((bp->row >= orp->row) && (bp->row < orp->row + orp->height) && (bp->col >= orp->col) && (bp->col < orp->col + orp->width)) {
					bp->rd = -bp->rd;
          bp->cd = -bp->cd;
          cs.score++;
        }

        if (cs.score <= 3) {
          cs.level = 1;
        } else if (cs.score <= 6) {
          cs.level = 2;
        } else {
          cs.level = 3;
        }

        break;
      case PAUSE:
        break;
      case QUIT:
        break;
      case WIN:
        break;
      case LOSE:
        break;
    };



    waitForVBlank();

    switch(cs.gamestate) {
      // Draw the initial splash screen image
		case INITSPLASH:
			// clear the screen to bgcolor
			//drawRectDMA(0, 0, WIDTH, HEIGHT, bgcolor);
      drawFullScreenImageDMA(beach);

			cs.gamestate = DRAWSPLASH;
			break;

		// Do the splash screen animation
		case DRAWSPLASH:
			//Erase the old ball
			obp = &ps.ball;
			drawImageDMA(obp->row, obp->col, ps.size, ps.size, beach);

      //Erase the old rectangle
      orp = &ps.rectangle;
      drawImageDMA(orp->row, orp->col, orp->width, orp->height, beach);

			// Draw the new ball
			bp = &cs.ball;
			drawImageDMA(bp->row, bp->col, cs.size, cs.size, star);

      //draw the new rectangle
      rp = &cs.rectangle;
			drawRectDMA(rp->row, rp->col, orp->width, orp->height, rp->color);
			
      cs.gamestate = WAITSPLASH;
      
      break;

		// Wait for the START key
		case WAITSPLASH: {
			char buffer[51];
			sprintf(buffer, "Press START to play...");
      drawImageDMA(150, 5, 200, 10, beach);
			drawString(150, 5, buffer, BLACK);

			if (buttonJustReleased[BUTTON_START])
				cs.gamestate = INITBOUNCE;
			break;
		}


    case INITBOUNCE:
      // clear the screen to bgcolor
			//drawRectDMA(0, 0, WIDTH, HEIGHT, bgcolor);
      drawFullScreenImageDMA(gamescreen);
		 	cs.gamestate = BOUNCE;
       break;


     case BOUNCE: {
      //erase old ball
      struct ball *obp = &ps.ball;
      drawImageDMA(obp->row, obp->col, ps.size, ps.size, gamescreen);
      // Draw the new ball
			bp = &cs.ball;
			drawImageDMA(bp->row, bp->col, cs.size, cs.size, star);

      //erase old rectangle
      orp = &ps.rectangle;
      drawImageDMA(orp->row, orp->col, orp->width, orp->height, gamescreen);
      //draw new rectangle
      rp = &cs.rectangle;
      drawRectDMA(rp->row, rp->col, rp->width, rp->height, rp->color);


			// Erase and draw the new score
		  char buffer[38];
      drawImageDMA(150, 5, 200, 10, gamescreen);
      if (cs.level == 1) {
        sprintf(buffer, "LEVEL 1 Score: %d, Lives: %d", cs.score, cs.lives);
      } else if (cs.level == 2) {
        sprintf(buffer, "LEVEL 2 Score: %d, Lives: %d", cs.score, cs.lives);
      } else if (cs.level == 3) {
        sprintf(buffer, "LEVEL 3 Score: %d, Lives: %d", cs.score, cs.lives);
      }
		  drawString(150, 5, buffer, BLACK);

			if (buttonJustReleased[BUTTON_A])
			  cs.gamestate = PAUSE;
			if (buttonJustReleased[BUTTON_SELECT])
			  cs.gamestate = QUIT;
      if (cs.score > 9)
        cs.gamestate = WIN;
      if (cs.lives <= 0)
        cs.gamestate = LOSE;
        
      break;
     }


    case PAUSE: {

      if (buttonJustReleased[BUTTON_A])
		    cs.gamestate = BOUNCE;
			if (buttonJustReleased[BUTTON_SELECT])
			  cs.gamestate = QUIT;
			break;
    }


    case QUIT: {
      drawFullScreenImageDMA(gameover);
      //drawString(HEIGHT / 2, (WIDTH - 9 * 6) / 2, "Game Over", RED);
			if (buttonJustReleased[BUTTON_SELECT])
			  cs.gamestate = INITSPLASH;
			break;
    }


    case WIN: {
      drawFullScreenImageDMA(youwon);
      //drawString(HEIGHT/2, (WIDTH - 9 * 6)/2, "Game Over: You Win!!", RED);
      if (buttonJustReleased[BUTTON_SELECT])
			  cs.gamestate = INITSPLASH;
      break;
    }
    case LOSE: {
      drawFullScreenImageDMA(Youlost);
      //drawString(HEIGHT/2, (WIDTH - 9 * 6)/2, "Game Over: You Lost", RED);
      if (buttonJustReleased[BUTTON_SELECT])
			  cs.gamestate = INITSPLASH;
      break;
    }



    }; //switch ending

  previousButtons = currentButtons; 

  UNUSED(previousButtons); // You can remove this once previousButtons is used
    // Store the current state of the buttons
     ps = cs;
  }




  

 // return 0;
}
