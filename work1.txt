#include "main.h"

#include <stdio.h>
#include <stdlib.h>

#include "gba.h"



/* TODO: */
// Include any header files for title screen or exit
// screen images generated by nin10kit. Example for the provided garbage
// image:
// #include "images/garbage.	

/* TODO: */
// Add any additional states you need for your app. You are not required to use
// these specific provided states.


int main(void) {
  /* TODO: */
  // Manipulate REG_DISPCNT here to set Mode 3. //
  REG_DISPCNT = MODE3 | BG2_ENABLE;


	int deltas[] = { -3, -2, -1, 1, 2, 3 };
	int ndeltas = sizeof(deltas) / sizeof(deltas[0]);
	int colors[] = { RED, BLUE, GREEN, WHITE, CYAN, YELLOW, MAGENTA };
	int ncolors = sizeof(colors) / sizeof(colors[0]);
	unsigned short bgcolor = BLACK;

	enum gamestate {
		GS_INITBOUNCE,
		GS_BOUNCE
	};

	// What it takes to define a ball
	struct ball {
		int row;
		int col;
		int rd;
		int cd;
		unsigned short color;
	}
	// All the info for the current state of the game	
	struct state {
		enum gamestate gamestate;
		int size;
		struct ball ball;
	};

	struct ball *bp, *obp;

	// current and previous states
	struct state cs, ps;

	cs.gamestate = GS_INITBOUNCE;
  /*
  REG_DISPCNT = MODE3 | BG2_ENABLE;

  setPixel(HEIGHT/2, WIDTH/2, 0xFF00);

  // Save current and previous state of button input.
  u32 previousButtons = BUTTONS;
  u32 currentButtons = BUTTONS;

  // Load initial app	Application state
  //enum gba_state state = START;
  //struct ball *bp;
  //struct rectangle *rp;

  //current and previous states
  struct state cs, ps;
  //cs.gamestate = STARTSCREEN;

  while (1) {
    currentButtons = BUTTONS; // Load the current state of the buttons

    
    // Manipulate the statemachine below as needed //
    // NOTE: Call waitForVBlank() before you draw

    switch (cs.gamestate) {
      case STARTSCREEN:
        // state = ?

        break;
      case INITBOUNCE:

        // state = ?
        break;
      case LEVEL1PLAY:

        // state = ?
        break;
      case LEVEL2PLAY:

        // state = ?
        break;
      case LEVEL3PLAY:

        break;
      case WIN:
        break;
      case LOSE:
        break;
      case QUIT:
        break;
    }

    previousButtons = currentButtons; // Store the current state of the buttons
  }
*/

while (1) {

		// Keep track of the state we're about to overwrite
		ps = cs;

		// Update button status
    /*
		for (int i=0; i<NBUTTONS; i++) {
			buttonJustReleased[i] = KEY_DOWN(i, BUTTONS) == 0 && buttonWasDown[i];
			buttonWasDown[i] = KEY_DOWN(i, BUTTONS) != 0;
		}
    */

		// Compute the graphics needed for the current state
		switch (cs.gamestate) {

		// Balls are bouncing
//need to add in condition for if ball touches rectangle (need to draw and undraw rect)
		case GS_BOUNCE:
			// See if we need to bounce off a wall
				bp = &cs.ball;
			bp->row = bp->row + bp->rd;
			bp->		col += bp->cd;
			if(bp->row < 0) {
				bp->row = 0;
				bp->rd = -bp->rd;
			}
			if(bp->row > HEIGHT-cs.size) {
				bp->row = HEIGHT - cs.size;
				bp->rd = -bp->rd;
			}
			if(bp->col < 0) {
				bp->col = 0;
				bp->cd = -bp->cd;
			}
			if(bp->col > WIDTH-cs.size) {
				bp->col = WIDTH - cs.size;
				bp->cd = -bp->cd;
			}
			break;

		case GS_INITBOUNCE:
			// initialize the parameters for bouncing
			cs.size = 5;
			cs.ball.row = rand() % HEIGHT;
			cs.ball.col = rand() % WIDTH;
			cs.ball.rd = deltas[rand() % ndeltas];
			cs.ball.cd = deltas[rand() % ndeltas];
			cs.ball.color = colors[rand() % ncolors];
			break;

		}

		// Wait for a Vblank to update the screen
		waitForVBlank();

		// Do the drawing and choose the next state
		switch (cs.gamestate) {

		// Draw the initial splash screen image
		// Initialize the balls for bouncing
		case GS_INITBOUNCE:
			cs.gamestate = GS_BOUNCE;
			break;

		// Bounce the ball around
		case GS_BOUNCE:
			// Erase the old balls
			obp = &ps.ball;
			drawRectDMA(obp->row, obp->col,
					ps.size, ps.size,
					bgcolor);

			break;

		}
	} // Game Loop
}




 // UNUSED(previousButtons); // You can remove this once previousButtons is used

  //return 0;
//}
